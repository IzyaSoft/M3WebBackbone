
M3WebBackbone.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000cc  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000001c8  000000cc  000000cc  000100cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  00000294  00000294  00020400  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .init_array   00000004  00000294  00000294  00010294  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  00000298  00000298  00010298  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000000  10000000  0000069c  00020400  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .co_stack     00000400  10000000  0000029c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000020  10000400  0000069c  00020400  2**2
                  ALLOC
  8 ._user_heap_stack 00000100  10000420  0000069c  00020420  2**0
                  ALLOC
  9 .ARM.attributes 0000002b  00000000  00000000  00020400  2**0
                  CONTENTS, READONLY
 10 .debug_info   00000fd9  00000000  00000000  0002042b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00000432  00000000  00000000  00021404  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000005fa  00000000  00000000  00021836  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000000f0  00000000  00000000  00021e30  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000000c8  00000000  00000000  00021f20  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00000745  00000000  00000000  00021fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000005ff  00000000  00000000  0002272d  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  00022d2c  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000001f4  00000000  00000000  00022dac  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

000000cc <__do_global_dtors_aux>:
  cc:	b510      	push	{r4, lr}
  ce:	4c05      	ldr	r4, [pc, #20]	; (e4 <__do_global_dtors_aux+0x18>)
  d0:	7823      	ldrb	r3, [r4, #0]
  d2:	b933      	cbnz	r3, e2 <__do_global_dtors_aux+0x16>
  d4:	4b04      	ldr	r3, [pc, #16]	; (e8 <__do_global_dtors_aux+0x1c>)
  d6:	b113      	cbz	r3, de <__do_global_dtors_aux+0x12>
  d8:	4804      	ldr	r0, [pc, #16]	; (ec <__do_global_dtors_aux+0x20>)
  da:	f3af 8000 	nop.w
  de:	2301      	movs	r3, #1
  e0:	7023      	strb	r3, [r4, #0]
  e2:	bd10      	pop	{r4, pc}
  e4:	10000400 	.word	0x10000400
  e8:	00000000 	.word	0x00000000
  ec:	0000027c 	.word	0x0000027c

000000f0 <frame_dummy>:
  f0:	b508      	push	{r3, lr}
  f2:	4b03      	ldr	r3, [pc, #12]	; (100 <_Min_Stack_Size>)
  f4:	b11b      	cbz	r3, fe <frame_dummy+0xe>
  f6:	4903      	ldr	r1, [pc, #12]	; (104 <_Min_Stack_Size+0x4>)
  f8:	4803      	ldr	r0, [pc, #12]	; (108 <_Min_Stack_Size+0x8>)
  fa:	f3af 8000 	nop.w
  fe:	bd08      	pop	{r3, pc}
 100:	00000000 	.word	0x00000000
 104:	10000404 	.word	0x10000404
 108:	0000027c 	.word	0x0000027c

0000010c <ADC_IRQHandler>:
  *         preserving the system state for examination by a debugger.
  * @param  None
  * @retval None  
  */
static void Default_Handler(void) 
{
 10c:	e7fe      	b.n	10c <ADC_IRQHandler>
 10e:	bf00      	nop

00000110 <Default_Reset_Handler>:
  *         supplied main() routine is called. 
  * @param  None
  * @retval None
  */
void Default_Reset_Handler(void)
{
 110:	b508      	push	{r3, lr}
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 112:	4a10      	ldr	r2, [pc, #64]	; (154 <zero_loop+0x16>)
 114:	4b10      	ldr	r3, [pc, #64]	; (158 <zero_loop+0x1a>)
 116:	429a      	cmp	r2, r3
 118:	d20d      	bcs.n	136 <Default_Reset_Handler+0x26>
 11a:	43d0      	mvns	r0, r2
 11c:	490f      	ldr	r1, [pc, #60]	; (15c <zero_loop+0x1e>)
 11e:	4418      	add	r0, r3
 120:	460b      	mov	r3, r1
 122:	f020 0003 	bic.w	r0, r0, #3
 126:	3004      	adds	r0, #4
 128:	4408      	add	r0, r1
  {
    *(pulDest++) = *(pulSrc++);
 12a:	f853 1b04 	ldr.w	r1, [r3], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 12e:	4283      	cmp	r3, r0
  {
    *(pulDest++) = *(pulSrc++);
 130:	f842 1b04 	str.w	r1, [r2], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 134:	d1f9      	bne.n	12a <Default_Reset_Handler+0x1a>
    *(pulDest++) = *(pulSrc++);
  }
  
  /* Zero fill the bss segment.  This is done with inline assembly since this
     will clear the value of pulDest if it is not kept in a register. */
  __asm("  ldr     r0, =_sbss\n"
 136:	480a      	ldr	r0, [pc, #40]	; (160 <zero_loop+0x22>)
 138:	490a      	ldr	r1, [pc, #40]	; (164 <zero_loop+0x26>)
 13a:	f04f 0200 	mov.w	r2, #0

0000013e <zero_loop>:
 13e:	4288      	cmp	r0, r1
 140:	bfb8      	it	lt
 142:	f840 2b04 	strlt.w	r2, [r0], #4
 146:	dbfa      	blt.n	13e <zero_loop>
        "    it      lt\n"
        "    strlt   r2, [r0], #4\n"
        "    blt     zero_loop");

  /* Setup the microcontroller system. */
  SystemInit();
 148:	f000 f80e 	bl	168 <SystemInit>
	
  /* Call the application's entry point.*/
  main();
}
 14c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  /* Setup the microcontroller system. */
  SystemInit();
	
  /* Call the application's entry point.*/
  main();
 150:	f000 b892 	b.w	278 <main>
 154:	10000000 	.word	0x10000000
 158:	10000000 	.word	0x10000000
 15c:	0000029c 	.word	0x0000029c
 160:	10000400 	.word	0x10000400
 164:	10000420 	.word	0x10000420

00000168 <SystemInit>:
 *         Initialize the System.
 */
void SystemInit (void)
{
#if (CLOCK_SETUP)                       /* Clock Setup                        */
  LPC_SC->SCS       = SCS_Val;
 168:	4a3a      	ldr	r2, [pc, #232]	; (254 <SystemInit+0xec>)
 16a:	2320      	movs	r3, #32
 *
 * @brief  Setup the microcontroller system.
 *         Initialize the System.
 */
void SystemInit (void)
{
 16c:	b4f0      	push	{r4, r5, r6, r7}
#if (CLOCK_SETUP)                       /* Clock Setup                        */
  LPC_SC->SCS       = SCS_Val;
 16e:	f8c2 31a0 	str.w	r3, [r2, #416]	; 0x1a0
  if (LPC_SC->SCS & (1 << 5)) {             /* If Main Oscillator is enabled  */
 172:	f8d2 31a0 	ldr.w	r3, [r2, #416]	; 0x1a0
 176:	069d      	lsls	r5, r3, #26
 178:	d463      	bmi.n	242 <SystemInit+0xda>
    while ((LPC_SC->SCS & (1<<6)) == 0);/* Wait for Oscillator to be ready    */
  }

  LPC_SC->CCLKCFG   = CCLKCFG_Val;      /* Setup Clock Divider                */
 17a:	4b36      	ldr	r3, [pc, #216]	; (254 <SystemInit+0xec>)
  LPC_SC->PCLKSEL1  = PCLKSEL1_Val;

#if (PLL0_SETUP)
  LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for PLL0       */

  LPC_SC->PLL0CFG   = PLL0CFG_Val;      /* configure PLL0                     */
 17c:	4e36      	ldr	r6, [pc, #216]	; (258 <SystemInit+0xf0>)
  LPC_SC->PLL0FEED  = 0x55;

  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
  LPC_SC->PLL0FEED  = 0xAA;
  LPC_SC->PLL0FEED  = 0x55;
  while (!(LPC_SC->PLL0STAT & (1<<26)));/* Wait for PLOCK0                    */
 17e:	4619      	mov	r1, r3

  LPC_SC->CCLKCFG   = CCLKCFG_Val;      /* Setup Clock Divider                */
  /* Periphral clock must be selected before PLL0 enabling and connecting
   * - according errata.lpc1768-16.March.2010 -
   */
  LPC_SC->PCLKSEL0  = PCLKSEL0_Val;     /* Peripheral Clock Selection         */
 180:	2500      	movs	r5, #0
  LPC_SC->PCLKSEL1  = PCLKSEL1_Val;

#if (PLL0_SETUP)
  LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for PLL0       */
 182:	2401      	movs	r4, #1

  LPC_SC->PLL0CFG   = PLL0CFG_Val;      /* configure PLL0                     */
  LPC_SC->PLL0FEED  = 0xAA;
 184:	20aa      	movs	r0, #170	; 0xaa
  LPC_SC->PLL0FEED  = 0x55;
 186:	2255      	movs	r2, #85	; 0x55
  LPC_SC->SCS       = SCS_Val;
  if (LPC_SC->SCS & (1 << 5)) {             /* If Main Oscillator is enabled  */
    while ((LPC_SC->SCS & (1<<6)) == 0);/* Wait for Oscillator to be ready    */
  }

  LPC_SC->CCLKCFG   = CCLKCFG_Val;      /* Setup Clock Divider                */
 188:	2703      	movs	r7, #3
 18a:	f8c3 7104 	str.w	r7, [r3, #260]	; 0x104
  /* Periphral clock must be selected before PLL0 enabling and connecting
   * - according errata.lpc1768-16.March.2010 -
   */
  LPC_SC->PCLKSEL0  = PCLKSEL0_Val;     /* Peripheral Clock Selection         */
 18e:	f8c3 51a8 	str.w	r5, [r3, #424]	; 0x1a8
  LPC_SC->PCLKSEL1  = PCLKSEL1_Val;
 192:	f8c3 51ac 	str.w	r5, [r3, #428]	; 0x1ac

#if (PLL0_SETUP)
  LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for PLL0       */
 196:	f8c3 410c 	str.w	r4, [r3, #268]	; 0x10c

  LPC_SC->PLL0CFG   = PLL0CFG_Val;      /* configure PLL0                     */
 19a:	f8c3 6084 	str.w	r6, [r3, #132]	; 0x84
  LPC_SC->PLL0FEED  = 0xAA;
 19e:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
 1a2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
 1a6:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
  LPC_SC->PLL0FEED  = 0xAA;
 1aa:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
 1ae:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  while (!(LPC_SC->PLL0STAT & (1<<26)));/* Wait for PLOCK0                    */
 1b2:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 1b6:	4a27      	ldr	r2, [pc, #156]	; (254 <SystemInit+0xec>)
 1b8:	0158      	lsls	r0, r3, #5
 1ba:	d5fa      	bpl.n	1b2 <SystemInit+0x4a>

  LPC_SC->PLL0CON   = 0x03;             /* PLL0 Enable & Connect              */
  LPC_SC->PLL0FEED  = 0xAA;
  LPC_SC->PLL0FEED  = 0x55;
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
 1bc:	4611      	mov	r1, r2
  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
  LPC_SC->PLL0FEED  = 0xAA;
  LPC_SC->PLL0FEED  = 0x55;
  while (!(LPC_SC->PLL0STAT & (1<<26)));/* Wait for PLOCK0                    */

  LPC_SC->PLL0CON   = 0x03;             /* PLL0 Enable & Connect              */
 1be:	2403      	movs	r4, #3
  LPC_SC->PLL0FEED  = 0xAA;
 1c0:	20aa      	movs	r0, #170	; 0xaa
  LPC_SC->PLL0FEED  = 0x55;
 1c2:	2355      	movs	r3, #85	; 0x55
  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
  LPC_SC->PLL0FEED  = 0xAA;
  LPC_SC->PLL0FEED  = 0x55;
  while (!(LPC_SC->PLL0STAT & (1<<26)));/* Wait for PLOCK0                    */

  LPC_SC->PLL0CON   = 0x03;             /* PLL0 Enable & Connect              */
 1c4:	f8c2 4080 	str.w	r4, [r2, #128]	; 0x80
  LPC_SC->PLL0FEED  = 0xAA;
 1c8:	f8c2 008c 	str.w	r0, [r2, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
 1cc:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
 1d0:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 1d4:	4a1f      	ldr	r2, [pc, #124]	; (254 <SystemInit+0xec>)
 1d6:	f013 7f40 	tst.w	r3, #50331648	; 0x3000000
 1da:	d0f9      	beq.n	1d0 <SystemInit+0x68>
  LPC_SC->PLL1FEED  = 0x55;

  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
  LPC_SC->PLL1FEED  = 0xAA;
  LPC_SC->PLL1FEED  = 0x55;
  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */
 1dc:	4611      	mov	r1, r2
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
#endif

#if (PLL1_SETUP)
  LPC_SC->PLL1CFG   = PLL1CFG_Val;
  LPC_SC->PLL1FEED  = 0xAA;
 1de:	20aa      	movs	r0, #170	; 0xaa
  LPC_SC->PLL1FEED  = 0x55;
 1e0:	2355      	movs	r3, #85	; 0x55
  LPC_SC->PLL0FEED  = 0x55;
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
#endif

#if (PLL1_SETUP)
  LPC_SC->PLL1CFG   = PLL1CFG_Val;
 1e2:	2523      	movs	r5, #35	; 0x23
  LPC_SC->PLL1FEED  = 0xAA;
  LPC_SC->PLL1FEED  = 0x55;

  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
 1e4:	2401      	movs	r4, #1
  LPC_SC->PLL0FEED  = 0x55;
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
#endif

#if (PLL1_SETUP)
  LPC_SC->PLL1CFG   = PLL1CFG_Val;
 1e6:	f8c2 50a4 	str.w	r5, [r2, #164]	; 0xa4
  LPC_SC->PLL1FEED  = 0xAA;
 1ea:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
 1ee:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac

  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
 1f2:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
  LPC_SC->PLL1FEED  = 0xAA;
 1f6:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
 1fa:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */
 1fe:	f8d1 30a8 	ldr.w	r3, [r1, #168]	; 0xa8
 202:	4a14      	ldr	r2, [pc, #80]	; (254 <SystemInit+0xec>)
 204:	055b      	lsls	r3, r3, #21
 206:	d5fa      	bpl.n	1fe <SystemInit+0x96>

  LPC_SC->PLL1CON   = 0x03;             /* PLL1 Enable & Connect              */
  LPC_SC->PLL1FEED  = 0xAA;
  LPC_SC->PLL1FEED  = 0x55;
  while (!(LPC_SC->PLL1STAT & ((1<< 9) | (1<< 8))));/* Wait for PLLC1_STAT & PLLE1_STAT */
 208:	4611      	mov	r1, r2
  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
  LPC_SC->PLL1FEED  = 0xAA;
  LPC_SC->PLL1FEED  = 0x55;
  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */

  LPC_SC->PLL1CON   = 0x03;             /* PLL1 Enable & Connect              */
 20a:	2403      	movs	r4, #3
  LPC_SC->PLL1FEED  = 0xAA;
 20c:	20aa      	movs	r0, #170	; 0xaa
  LPC_SC->PLL1FEED  = 0x55;
 20e:	2355      	movs	r3, #85	; 0x55
  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
  LPC_SC->PLL1FEED  = 0xAA;
  LPC_SC->PLL1FEED  = 0x55;
  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */

  LPC_SC->PLL1CON   = 0x03;             /* PLL1 Enable & Connect              */
 210:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
  LPC_SC->PLL1FEED  = 0xAA;
 214:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
 218:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
  while (!(LPC_SC->PLL1STAT & ((1<< 9) | (1<< 8))));/* Wait for PLLC1_STAT & PLLE1_STAT */
 21c:	f8d1 30a8 	ldr.w	r3, [r1, #168]	; 0xa8
 220:	4a0c      	ldr	r2, [pc, #48]	; (254 <SystemInit+0xec>)
 222:	f413 7f40 	tst.w	r3, #768	; 0x300
 226:	d0f9      	beq.n	21c <SystemInit+0xb4>

  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
#endif

#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
  LPC_SC->FLASHCFG  = FLASHCFG_Val;
 228:	f243 003a 	movw	r0, #12346	; 0x303a
  LPC_SC->PLL1FEED  = 0x55;
  while (!(LPC_SC->PLL1STAT & ((1<< 9) | (1<< 8))));/* Wait for PLLC1_STAT & PLLE1_STAT */
#else
  LPC_SC->USBCLKCFG = USBCLKCFG_Val;    /* Setup USB Clock Divider            */
#endif
  LPC_SC->PCONP     = PCONP_Val;        /* Power Control for Peripherals      */
 22c:	4c0b      	ldr	r4, [pc, #44]	; (25c <SystemInit+0xf4>)

//  Set Vector table offset value
#if (__RAM_MODE__==1)
  SCB->VTOR  = 0x10000000 & 0x3FFFFF80;
#else
  SCB->VTOR  = 0x00000000 & 0x3FFFFF80;
 22e:	490c      	ldr	r1, [pc, #48]	; (260 <SystemInit+0xf8>)
#else
  LPC_SC->USBCLKCFG = USBCLKCFG_Val;    /* Setup USB Clock Divider            */
#endif
  LPC_SC->PCONP     = PCONP_Val;        /* Power Control for Peripherals      */

  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
 230:	2300      	movs	r3, #0
  LPC_SC->PLL1FEED  = 0x55;
  while (!(LPC_SC->PLL1STAT & ((1<< 9) | (1<< 8))));/* Wait for PLLC1_STAT & PLLE1_STAT */
#else
  LPC_SC->USBCLKCFG = USBCLKCFG_Val;    /* Setup USB Clock Divider            */
#endif
  LPC_SC->PCONP     = PCONP_Val;        /* Power Control for Peripherals      */
 232:	f8c2 40c4 	str.w	r4, [r2, #196]	; 0xc4

  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
 236:	f8c2 31c8 	str.w	r3, [r2, #456]	; 0x1c8
#if (__RAM_MODE__==1)
  SCB->VTOR  = 0x10000000 & 0x3FFFFF80;
#else
  SCB->VTOR  = 0x00000000 & 0x3FFFFF80;
#endif
}
 23a:	bcf0      	pop	{r4, r5, r6, r7}

  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
#endif

#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
  LPC_SC->FLASHCFG  = FLASHCFG_Val;
 23c:	6010      	str	r0, [r2, #0]

//  Set Vector table offset value
#if (__RAM_MODE__==1)
  SCB->VTOR  = 0x10000000 & 0x3FFFFF80;
#else
  SCB->VTOR  = 0x00000000 & 0x3FFFFF80;
 23e:	608b      	str	r3, [r1, #8]
#endif
}
 240:	4770      	bx	lr
void SystemInit (void)
{
#if (CLOCK_SETUP)                       /* Clock Setup                        */
  LPC_SC->SCS       = SCS_Val;
  if (LPC_SC->SCS & (1 << 5)) {             /* If Main Oscillator is enabled  */
    while ((LPC_SC->SCS & (1<<6)) == 0);/* Wait for Oscillator to be ready    */
 242:	f8d2 31a0 	ldr.w	r3, [r2, #416]	; 0x1a0
 246:	065c      	lsls	r4, r3, #25
 248:	d497      	bmi.n	17a <SystemInit+0x12>
 24a:	f8d2 31a0 	ldr.w	r3, [r2, #416]	; 0x1a0
 24e:	065c      	lsls	r4, r3, #25
 250:	d5f7      	bpl.n	242 <SystemInit+0xda>
 252:	e792      	b.n	17a <SystemInit+0x12>
 254:	400fc000 	.word	0x400fc000
 258:	00050063 	.word	0x00050063
 25c:	042887de 	.word	0x042887de
 260:	e000ed00 	.word	0xe000ed00

00000264 <SysTick_Handler>:
 * ------------------------------------------------------------------------------------------------
 */

void SysTick_Handler(void)
 {
  if (SysTickCounter != 0)
 264:	4b03      	ldr	r3, [pc, #12]	; (274 <SysTick_Handler+0x10>)
 266:	681a      	ldr	r2, [r3, #0]
 268:	b112      	cbz	r2, 270 <SysTick_Handler+0xc>
   SysTickCounter--;
 26a:	681a      	ldr	r2, [r3, #0]
 26c:	3a01      	subs	r2, #1
 26e:	601a      	str	r2, [r3, #0]
 270:	4770      	bx	lr
 272:	bf00      	nop
 274:	1000041c 	.word	0x1000041c

00000278 <main>:


int main()
{
    return 0;
}
 278:	2000      	movs	r0, #0
 27a:	4770      	bx	lr

0000027c <_init>:
 27c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 27e:	bf00      	nop
 280:	bcf8      	pop	{r3, r4, r5, r6, r7}
 282:	bc08      	pop	{r3}
 284:	469e      	mov	lr, r3
 286:	4770      	bx	lr

00000288 <_fini>:
 288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 28a:	bf00      	nop
 28c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 28e:	bc08      	pop	{r3}
 290:	469e      	mov	lr, r3
 292:	4770      	bx	lr
